function [expDes]=designConfig(const)
% ----------------------------------------------------------------------
% [expDes]=designConfig(const)
% ----------------------------------------------------------------------
% Goal of the function :
% Define experimental design
% ----------------------------------------------------------------------
% Input(s) :
% const : struct containing constant configurations
% ----------------------------------------------------------------------
% Output(s):
% expDes : struct containg experimental design
% ----------------------------------------------------------------------
% Function created by Martin SZINTE (martin.szinte@gmail.com)
% Project : nCSFexp
% Version : 1.0
% ----------------------------------------------------------------------

% Fix randomization
rng(const.seed);

%% Experimental random variables

% Var 1 : Spatial Frequency
% ======
expDes.oneV = linspace(1, const.sp_stepCut, const.sp_stepCut)';
expDes.txt_var1 = cellfun(@(x) sprintf('%.2f cycle/dva', x), ...
    num2cell(const.sp_cutCenters), 'UniformOutput', false);
expDes.txt_var1{end+1} = 'none';

% Var 2 : Michelson contrast
% ======
expDes.twoV = linspace(1, const.mc_stepCont, const.mc_stepCont)';
expDes.txt_var2 = cellfun(@(x) sprintf('%.2f %%', x*100), ...
    num2cell(const.mc_values), 'UniformOutput', false);
expDes.txt_var2{end+1} = 'none';

% Sequence : ascending or descending contrast gradient
% =========
expDes.sequence = [3, 2, 1];                                                 % 1: ascending contrast; 2: descending contrast; 3: blank
expDes.sequences = repmat(expDes.sequence, 1, const.sp_stepCut);
expDes.sequences = [expDes.sequences, 3];                                     % add last blank

% Rand 1: stim orientation
% =======
expDes.oneR = [1;2];
expDes.txt_rand1 = {'cw', 'ccw', 'none'};

% Staircase
% ---------
% To be done 

% seq order
% % ---------
% if const.runNum == 1
%     % Create spatial frequency sequence order
%     expDes.sp_sequence_order = randDraw(expDes.oneV, const.repetition_sp_sequence);
% 
%     % Ascending or descending first contrast gradient
%     expDes.gradient_sequence_order = expDes.threeV(randperm(length(expDes.threeV)));
%  
%     % Export sequence_order_file
%     sp_sequence_order = expDes.sp_sequence_order;
%     gradient_sequence_order = expDes.gradient_sequence_order;
% 
%     save(const.sequence_order_file, 'sp_sequence_order', 'gradient_sequence_order');
% else
%     load(const.sequence_order_file);
%     expDes.sp_sequence_order = sp_sequence_order;
%     expDes.gradient_sequence_order = gradient_sequence_order;
% end

% %% Experimental configuration :
% expDes.nb_cond          =   0;
% expDes.nb_var           =   3;
% expDes.nb_rand          =   1;
% expDes.nb_list          =   0;
% 
% %% Experimental loop
% runT                    =   const.runNum;
% 
% % introduce brakes between spatial frequency
% expDes.sp_brake_val = max(expDes.oneV) + 1; 
% expDes.sp_sequence_order_with_brakes = [expDes.sp_brake_val;...
%     reshape([expDes.sp_sequence_order, expDes.sp_brake_val * ones(length(expDes.sp_sequence_order)...
%     , 1)]', [], 1)];
% 
% % Define the first contrast gradient
% if expDes.gradient_sequence_order(1) == 1
%     gradient             = expDes.twoV;
% else
%     gradient             = flipud(expDes.twoV);
% end
% 
% t_trial = 0;
% loop_gradient_sequence_order = expDes.gradient_sequence_order;
% % Loop through the spatial sequence 
% for ii = 1:length(expDes.sp_sequence_order_with_brakes)
%     t_sp = expDes.sp_sequence_order_with_brakes(ii);
%     % If spatial frequency is 7, apply a break 
%     if t_sp == 7
%         for j = 1:const.length_break
%             t_cont          = 7;
%             t_ori           = 3;
%             t_cont_gradien  = 3;
%             t_trial        = t_trial + 1;
%     
%             % Update expMat
%             expDes.expMat(t_trial, :) = [runT, t_trial, ...
%                 t_sp, t_cont_gradien, t_cont, t_ori, ...
%                 NaN, NaN, NaN, NaN, NaN, NaN];
%         end
% 
%     % Otherwise, generate contrast gradient
%     else
%         % loop over the contrast
%         for iii = 1:length(expDes.twoV)
%             t_cont_gradien  = loop_gradient_sequence_order(1);
%             t_cont        = gradient(iii);
%             t_ori     = expDes.oneR(randperm(length(expDes.oneR), 1));
%             t_trial = t_trial + 1;
% 
%             % Update expMat
%             expDes.expMat(t_trial, :) = [runT, t_trial, ...
%                 t_sp, t_cont_gradien, t_cont, t_ori, ...
%                 NaN, NaN, NaN, NaN, NaN, NaN];
% 
%             % col 01:   Run number
%             % col 02:   Trial number
%             % col 03:   Sequence
%             % col 04:   Spatial frequency
%             % col 05:   Contrast
%             % col 06:   Stimulus noise orientation
%             % col 07:   Trial onset time
%             % col 08:   Trial offset time
%             % col 09:   Stimulus noise staircase value
%             % col 10:   Stimulus noise staircase value
%             % col 11:   Probe time
%             % col 12:   Response time
% 
%         end
%         % Flip the gradient after each spatial frequency iteration
%         gradient = flipud(gradient);
%         loop_gradient_sequence_order = flipud(loop_gradient_sequence_order);
%     end
% end
% expDes.nb_trials = size(expDes.expMat,1);
% 

expDes.expMat = zeros(const.nb_trials,  12);
constrast_seqs = [];
sf_ascending = randperm(const.sp_stepCut);
sf_descending = randperm(const.sp_stepCut);

for seq = expDes.sequences
    num_seq = num_seq + 1;
    if seq == 1 % ascending
        %trial_seq = linspace(1, const.mc_stepCont, const.mc_stepCont);
        constrast_seq = linspace(1, const.mc_stepCont, const.mc_stepCont);
        sf_seq = 
    elseif seq == 2 % descending
        constrast_seq = linspace(const.mc_stepCont, 1, const.mc_stepCont);
        
    elseif seq == 3 % pause
        constrast_seq = repmat(const.mc_stepCont + 1, 1, const.break_trs);
        
    end
    
    constrast_seqs = [constrast_seqs; constrast_seq'];
end

end
